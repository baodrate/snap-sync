#!/bin/bash
# James W. Barnett

# Takes snapshots of each snapper configuration. It then sends the snapshot to
# a location on an external drive. After the initial transfer, it does
# incremental snapshots on later calls. It's important not to delete the
# snapshot created on your system since that will be used to determine the
# difference for the next incremental snapshot.

version="0.3"
name="snap-sync"

function error_exit 
{
    for u in $(users); do
        notify_cmd="sudo -u $u DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(sudo -u $u id -u)/bus notify-send"
        $notify_cmd -a $name 'Error' 'Check journal for more information.' --icon=dialog-error
    done
    printf "\nExited due to error.\n" | tee $PIPE
    exit 1
}

function kill_exit 
{
    printf "\nExited due to user intervention.\n" | tee $PIPE
    exit 1
}

trap error_exit ERR
trap kill_exit SIGTERM SIGINT

while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -d|--description)
            description="$2"
            shift 2
        ;;
        -c|--config)
            selected_configs="$2"
            shift 2
        ;;
        -u|--UUID)
            uuid_cmdline="$2"
            shift 2
        ;;
        -n|--noconfirm)
            noconfirm="yes"
            shift
        ;;
        -h|--help)
            printf "$name $version\n\n"
            printf "Usage: $name [options]\n\n"
            printf "Options:\n"
            printf " -d, --description <desc> Change the snapper description. Default: \"latest incremental backup\"\n"
            printf " -c, --config <config>    Specify the snapper configuration to use. Otherwise will perform for each snapper\n"
            printf "                          configuration. Can list multiple configurations within quotes, space-separated\n"
            printf "                          (e.g. -c \"root home\").\n"
            printf " -n, --noconfirm          Do not ask for confirmation for each configuration. Will still prompt for backup\n"
            printf "                          directory name on first backup\n"
            printf " -u, --UUID <UUID>        Specify the UUID of the mounted BTRFS subvolume to back up to. Otherwise will prompt.\n"
            printf "                          If multiple mount points are found with the same UUID, will prompt user.\n"
            exit 1
        ;;
        *)
            printf "ERROR: Unknown option: $key\n"
            printf "Run '$name -h' for valid options.\n"
            exit 1
        ;;
    esac
done

description=${description:-"latest incremental backup"}
uuid_cmdline=${uuid_cmdline:-"none"}
noconfirm=${noconfirm:-"no"}

for u in $(users); do
    notify_cmd="sudo -u $u DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(sudo -u $u id -u)/bus notify-send"
    if [[ "$uuid_cmdline" != "none" ]]; then
        $notify_cmd -a $name 'Backup started' 'Starting backups to '$uuid_cmdline'...' --icon=dialog-information
    else
        $notify_cmd -a $name 'Backup started' 'Starting backups. Use command line menu to select disk.'  --icon=dialog-information
    fi
done

if [[ $EUID -ne 0 ]]; then
    printf "Script must be run as root.\n" 
    exit
fi

TMPDIR=$(mktemp -d)
PIPE=$TMPDIR/$name.out
mkfifo $PIPE
systemd-cat -t "$name" < $PIPE &
exec 3>$PIPE

TARGETS="$(findmnt -n -v -t btrfs -o TARGET --list)"
UUIDS="$(findmnt -n -v -t btrfs -o UUID --list)"

declare -a TARGETS_ARRAY
declare -a UUIDS_ARRAY

i=0
disk=-1
disk_count=0
for x in $UUIDS; do
    UUIDS_ARRAY[$i]=$x
    if [[ "$x" == "$uuid_cmdline" ]]; then
        disk=$i
        disk_count=$(($disk_count+1))
    fi
    i=$((i+1))
done

i=0
for x in $TARGETS; do
    TARGETS_ARRAY[$i]=$x
    i=$((i+1))
done

if [[ "$disk_count" > 1 ]]; then
    printf "Multiple mount points were found with UUID $uuid_cmdline.\n"
    disk="-1"
fi

if [[ "$disk" == -1 ]]; then
    if [[ "$disk_count" == 0 && "$uuid_cmdline" != "none" ]]; then
        printf "ERROR: A device with UUID $uuid_cmdline was not found to be mounted, or it is not a BTRFS device.\n"
        for u in $(users); do
            notify_cmd="sudo -u $u DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(sudo -u $u id -u)/bus notify-send"
            $notify_cmd -a $name 'Error' 'No disk with '$uuid_cmdline' mounted.' --icon=dialog-error
        done
    fi
    printf "Select a mounted BTRFS device to backup to.\n"
    while [[ $disk -lt 0 || $disk -gt $i ]]; do
        for x in "${!TARGETS_ARRAY[@]}"; do
            printf "%4s) %s (%s)\n" "$((x+1))" "${UUIDS_ARRAY[$x]}" "${TARGETS_ARRAY[$x]}"
        done
        printf "%4s) Exit\n" "0"
        read -r -p "Enter a number: " disk
    done
    if [[ $disk == 0 ]]; then
        exit 0
    fi
    disk=$(($disk-1))
fi

selected_uuid="${UUIDS_ARRAY[$((disk))]}"
selected_mnt="${TARGETS_ARRAY[$((disk))]}"
printf "\nYou selected the disk with UUID %s.\n" "$selected_uuid" | tee $PIPE
printf "The disk is mounted at %s.\n" "$selected_mnt" | tee $PIPE

if [[ -f /etc/conf.d/snapper ]]; then
    source /etc/conf.d/snapper 
else
    printf "ERROR: /etc/conf.d/snapper does not exist!\n" | tee $PIPE
    error_exit
fi

selected_configs=${selected_configs:-$SNAPPER_CONFIGS}

declare -a BACKUPDIRS_ARRAY
declare -a MYBACKUPDIR_ARRAY
declare -a OLD_NUM_ARRAY
declare -a OLD_SNAP_ARRAY
declare -a NEW_NUM_ARRAY
declare -a NEW_SNAP_ARRAY
declare -a NEW_INFO_ARRAY
declare -a BACKUPLOC_ARRAY
declare -a CONT_BACKUP_ARRAY

printf "Initial configuration..." | tee $PIPE

# Initial configuration of where backup directories are
i=0
for x in $selected_configs; do

    if [[ "$(sudo snapper -c $x list -t single | awk '/'$name' backup in progress/ {cnt++} END {print cnt}')" -gt 0 ]]; then
        printf "\nNOTE: Previous failed $name backup snapshots found for '$x'.\n" | tee $PIPE
    fi

    SNAP_SYNC_EXCLUDE=no

    if [[ -f "/etc/snapper/configs/$x" ]]; then
        source /etc/snapper/configs/$x
    else
        printf "ERROR: Selected snapper configuration $x does not exist.\n"
        error_exit
    fi

    if [[ $SNAP_SYNC_EXCLUDE == "yes" ]]; then 
        continue
    fi

    old_num=$(snapper -c "$x" list -t single | awk '/'"$selected_uuid"'/ {print $1}')
    old_snap=$SUBVOLUME/.snapshots/$old_num/snapshot

    OLD_NUM_ARRAY[$i]=$old_num
    OLD_SNAP_ARRAY[$i]=$old_snap

    if [[ -z "$old_num" ]]; then
        printf "No backups have been performed for '%s' on this disk.\n" "$x"
        read -r -p "Enter name of directory to store backups, relative to $selected_mnt (to be created if not existing): " mybackupdir
        printf "This will be the initial backup for snapper configuration '%s' to this disk. This could take awhile.\n" "$x"
        BACKUPDIR="$selected_mnt/$mybackupdir"
        mkdir -p -m700 "$BACKUPDIR"
    else
        mybackupdir=$(snapper -c root list -t single | awk -F"|" '/'"$selected_uuid"'/ {print $5}' | awk -F "," '/backupdir/ {print $1}' | awk -F"=" '{print $2}')
        BACKUPDIR="$selected_mnt/$mybackupdir"
        if [[ ! -d $BACKUPDIR ]]; then
            printf "ERROR: %s is not a directory on %s.\n" "$BACKUPDIR" "$selected_uuid" | tee $PIPE
            error_exit
        fi
    fi
    BACKUPDIRS_ARRAY[$i]="$BACKUPDIR"
    MYBACKUPDIR_ARRAY[$i]="$mybackupdir"

    printf "Creating new snapshot for $x...\n" | tee $PIPE
    new_num=$(snapper -c "$x" create --print-number -d "$name backup in progress")
    new_snap=$SUBVOLUME/.snapshots/$new_num/snapshot
    new_info=$SUBVOLUME/.snapshots/$new_num/info.xml
    sync
    backup_location=$BACKUPDIR/$x/$new_num/
    printf "Will backup %s to %s\n" "$new_snap" "$backup_location/snapshot" | tee $PIPE

    NEW_NUM_ARRAY[$i]="$new_num"
    NEW_SNAP_ARRAY[$i]="$new_snap"
    NEW_INFO_ARRAY[$i]="$new_info"
    BACKUPLOC_ARRAY[$i]="$backup_location"

    cont_backup="K"
    CONT_BACKUP_ARRAY[$i]="yes"
    if [[ $noconfirm == "yes" ]]; then
        cont_backup="yes"
    else
        while [[ -n "$cont_backup" && "$cont_backup" != [Yy]"es" &&
            "$cont_backup" != [Yy] && "$cont_backup" != [Nn]"o" &&
            "$cont_backup" != [Nn] ]]; do
            read -r -p "Continue with backup [Y/n]? " cont_backup
            if [[ -n "$cont_backup" && "$cont_backup" != [Yy]"es" &&
            "$cont_backup" != [Yy] && "$cont_backup" != [Nn]"o" &&
            "$cont_backup" != [Nn] ]]; then
                printf "Select 'Y' or 'n'.\n"
            fi
        done
    fi

    if [[ "$cont_backup" != [Yy]"es" && "$cont_backup" != [Yy] && -n "$cont_backup" ]]; then
        CONT_BACKUP_ARRAY[$i]="no"
        printf "Aborting backup for this configuration.\n"
        snapper -c $x delete $new_num
    fi

    i=$(($i+1))

done

# Actual backing up
printf "Performing backups..." | tee $PIPE
i=-1
for x in $selected_configs; do

    i=$(($i+1))

    SNAP_SYNC_EXCLUDE=no

    if [[ -f "/etc/snapper/configs/$x" ]]; then
        source /etc/snapper/configs/$x
    else
        printf "ERROR: Selected snapper configuration $x does not exist.\n"
        error_exit
    fi

    cont_backup=${CONT_BACKUP_ARRAY[$i]}
    if [[ $cont_backup == "no" || $SNAP_SYNC_EXCLUDE == "yes" ]]; then 
        $notify_cmd -a $name 'Backup in progress' 'Skipping '$x' configuration.' --icon=dialog-information
        continue
    fi

    $notify_cmd -a $name 'Backup in progress' 'Backing up '$x' configuration.' --icon=dialog-information

    printf "\n"

    old_num="${OLD_NUM_ARRAY[$i]}"
    old_snap="${OLD_SNAP_ARRAY[$i]}"
    BACKUPDIR="${BACKUPDIRS_ARRAY[$i]}"
    mybackupdir="${MYBACKUPDIR_ARRAY[$i]}"
    new_num="${NEW_NUM_ARRAY[$i]}"
    new_snap="${NEW_SNAP_ARRAY[$i]}"
    new_info="${NEW_INFO_ARRAY[$i]}"
    backup_location="${BACKUPLOC_ARRAY[$i]}"

    mkdir -p "$backup_location"

    if [[ -z "$old_num" ]]; then
        printf "Sending first snapshot for %s...\n" "$x" | tee $PIPE  
        btrfs send "$new_snap" | btrfs receive "$backup_location" &>/dev/null

    else

        printf "Sending incremental snapshot for %s...\n" "$x" | tee $PIPE  
        # Sends the difference between the new snapshot and old snapshot to the
        # backup location. Using the -c flag instead of -p tells it that there
        # is an identical subvolume to the old snapshot at the receiving
        # location where it can get its data. This helps speed up the transfer.
        btrfs send "$new_snap" -c "$old_snap" | btrfs receive "$backup_location" &>/dev/null
        printf "Deleting old snapshot for $x...\n" | tee $PIPE
        snapper -c "$x" delete "$old_num"
    fi

    cp "$new_info" "$backup_location"

    # It's important not to change this userdata in the snapshots, since that's how
    # we find the previous one.

    userdata="backupdir=$mybackupdir, uuid=$selected_uuid"

    # Tag new snapshot as the latest
    printf "Tagging new snapshot as latest backup for $x...\n" | tee $PIPE
    snapper -v -c "$x" modify -d "$description" -u "$userdata" "$new_num"

    printf "Backup complete for configuration %s.\n" "$x" > $PIPE

done

printf "\nDone!\n" | tee $PIPE
exec 3>&-

for u in $(users); do
    notify_cmd="sudo -u $u DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(sudo -u $u id -u)/bus notify-send"
    if [[ "$uuid_cmdline" != "none" ]]; then
        $notify_cmd -a $name 'Finished' 'Backups to '$uuid_cmdline' complete!' --icon=dialog-information
    else
        $notify_cmd -a $name 'Finished' 'Backups complete!' --icon=dialog-information
    fi
done
